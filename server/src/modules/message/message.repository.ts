import prisma from '@/lib/prisma';
import type { Message, Conversation, User, MessageStatus, Prisma } from '@prisma/client';

/**
 * Message with populated conversation
 */
export interface MessageWithConversation extends Message {
    conversation: Conversation | null;
}

export interface PaginationQuery {
    page?: number;
    limit?: number;
}

export interface SearchQuery extends PaginationQuery {
    query: string;
    conversationId?: string;
}

/**
 * Repository for message database operations with Prisma
 */
export class MessageRepository {
    /**
     * Finds all messages for a conversation with pagination
     */
    public async findByConversation(
        conversationId: string,
        options: PaginationQuery = {}
    ): Promise<{ messages: Message[]; total: number }> {
        const page = options.page || 1;
        const limit = Math.min(options.limit || 25, 100);
        const skip = (page - 1) * limit;

        const [messages, total] = await Promise.all([
            prisma.message.findMany({
                where: { conversationId },
                orderBy: { timestamp: 'desc' }, // Newest first
                skip,
                take: limit,
            }),
            prisma.message.count({
                where: { conversationId },
            }),
        ]);

        return { messages, total };
    }

    /**
     * Searches messages by text content
     */
    public async searchMessages(
        userWaId: string,
        searchQuery: SearchQuery
    ): Promise<{ messages: MessageWithConversation[]; total: number }> {
        const page = searchQuery.page || 1;
        const limit = Math.min(searchQuery.limit || 25, 100);
        const skip = (page - 1) * limit;

        const normalizeWaId = (id: string) =>
            id?.startsWith('91') ? id.trim() : `91${id.trim()}`;
        const currentWaId = normalizeWaId(userWaId);

        // Build where clause
        const where: Prisma.MessageWhereInput = {
            OR: [{ from: currentWaId }, { to: currentWaId }],
            text: {
                contains: searchQuery.query.trim(),
                mode: 'insensitive',
            },
        };

        // Filter by specific conversation if provided
        if (searchQuery.conversationId) {
            where.conversationId = searchQuery.conversationId;
        }

        const [messages, total] = await Promise.all([
            prisma.message.findMany({
                where,
                orderBy: { timestamp: 'desc' },
                skip,
                take: limit,
                include: {
                    conversation: true,
                },
            }),
            prisma.message.count({ where }),
        ]);

        return { messages, total };
    }

    /**
     * Creates a new message and updates/creates conversation
     */
    public async create(data: {
        from: string;
        to: string;
        text: string;
        type?: string;
        senderUser: User;
        receiverUser: User;
    }): Promise<{ message: Message; conversation: Conversation }> {
        const normalizeWaId = (id: string) =>
            id?.startsWith('91') ? id.trim() : `91${id.trim()}`;

        const fromId = normalizeWaId(data.from);
        const toId = normalizeWaId(data.to);

        // Find existing conversation
        let conversation = await prisma.conversation.findFirst({
            where: {
                AND: [
                    {
                        participants: {
                            some: { waId: fromId },
                        },
                    },
                    {
                        participants: {
                            some: { waId: toId },
                        },
                    },
                ],
            },
        });

        const timestamp = Date.now();

        // Create or update conversation
        if (!conversation) {
            conversation = await prisma.conversation.create({
                data: {
                    conversationId: '', // Will be auto-generated by Prisma
                    participants: [
                        {
                            waId: fromId,
                            name: data.senderUser.name || `User ${fromId}`,
                            profilePicture: data.senderUser.profilePicture,
                        },
                        {
                            waId: toId,
                            name: data.receiverUser.name || `User ${toId}`,
                            profilePicture: data.receiverUser.profilePicture,
                        },
                    ],
                    lastMessage: {
                        text: data.text,
                        timestamp,
                        from: fromId,
                        status: 'sent',
                    },
                    unreadCount: 1,
                },
            });
        }

        // Create message
        const message = await prisma.message.create({
            data: {
                conversationId: conversation.id,
                from: fromId,
                to: toId,
                text: data.text,
                timestamp,
                status: 'sent',
                type: (data.type as any) || 'text',
                waId: fromId,
                direction: 'outgoing',
                contact: {
                    name: data.senderUser.name || `User ${fromId}`,
                    waId: fromId,
                },
            },
        });

        // Update conversation's last message
        conversation = await prisma.conversation.update({
            where: { id: conversation.id },
            data: {
                lastMessage: {
                    text: data.text,
                    timestamp: message.timestamp,
                    from: fromId,
                    status: 'sent',
                },
                unreadCount: { increment: 1 },
            },
        });

        return { message, conversation };
    }

    /**
     * Updates message status
     */
    public async updateStatus(
        messageId: string,
        status: MessageStatus
    ): Promise<Message | null> {
        return prisma.message.update({
            where: { id: messageId },
            data: { status },
        });
    }

    /**
     * Checks if user is participant in conversation
     */
    public async isUserParticipant(
        userWaId: string,
        conversationId: string
    ): Promise<boolean> {
        const normalizeWaId = (id: string) =>
            id?.startsWith('91') ? id.trim() : `91${id.trim()}`;
        const currentWaId = normalizeWaId(userWaId);

        const conversation = await prisma.conversation.findUnique({
            where: { id: conversationId },
        });

        if (!conversation || !conversation.participants) return false;

        return (conversation.participants as any[]).some((p: any) => p?.waId === currentWaId);
    }

    /**
     * Resolves conversationId (handles both ObjectId and unique conversationId field)
     */
    public async resolveConversationId(conversationId: string): Promise<string | null> {
        // Try to find by ID first
        let conversation = await prisma.conversation.findUnique({
            where: { id: conversationId },
            select: { id: true },
        });

        if (conversation) return conversation.id;

        // Try to find by the conversationId field
        conversation = await prisma.conversation.findUnique({
            where: { conversationId },
            select: { id: true },
        });

        return conversation?.id || null;
    }

    /**
     * Gets conversation by ID
     */
    public async getConversation(conversationId: string): Promise<Conversation | null> {
        return prisma.conversation.findUnique({
            where: { id: conversationId },
        });
    }

    /**
     * Gets user by waId
     */
    public async getUserByWaId(waId: string): Promise<User | null> {
        return prisma.user.findUnique({
            where: { waId },
        });
    }
}

export default new MessageRepository();
